<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/agents/diagramador/app/engines/pyarchimate/quality_improver.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/agents/diagramador/app/engines/pyarchimate/quality_improver.py" />
              <option name="originalContent" value="&quot;&quot;&quot;&#10;Aplicador de Melhorias de Qualidade C4&#10;Implementa automaticamente as recomendações da validação de qualidade&#10;Versão otimizada para diagramas de container C4&#10;&quot;&quot;&quot;&#10;&#10;import xml.etree.ElementTree as ET&#10;from pathlib import Path&#10;from typing import Dict, List, Optional, Set&#10;import logging&#10;import re&#10;from .naming_conventions import NamingConventionApplier, apply_naming_improvements&#10;&#10;logger = logging.getLogger(__name__)&#10;&#10;class C4QualityImprover:&#10;    &quot;&quot;&quot;Aplica melhorias automáticas baseadas na validação de qualidade&quot;&quot;&quot;&#10;&#10;    def __init__(self):&#10;        self.naming_applier = NamingConventionApplier()&#10;        self.namespaces = {&#10;            'archimate': 'http://www.opengroup.org/xsd/archimate/3.0/',&#10;            'dc': 'http://purl.org/dc/elements/1.1/',&#10;            'xsi': 'http://www.w3.org/2001/XMLSchema-instance'&#10;        }&#10;        &#10;        # Padrões C4 para container diagram&#10;        self.c4_container_patterns = {&#10;            'web_app': ['Web App', 'Portal', 'Frontend', 'UI'],&#10;            'mobile_app': ['Mobile', 'App', 'Android', 'iOS'],&#10;            'api_gateway': ['Gateway', 'API Gateway', 'Proxy'],&#10;            'microservice': ['Service', 'Microservice', 'Component'],&#10;            'message_queue': ['Queue', 'Broker', 'Event Bus'],&#10;            'message_queue': ['Queue', 'Broker', 'Event Bus'],&#10;            'external_system': ['External', 'Third Party', 'Legacy']&#10;            # 2. Aplicar tipos corretos de elementos C4&#10;            self._apply_c4_element_types(root)&#10;            improvements_applied.append(&quot;Tipos de elementos C4 aplicados&quot;)&#10;&#10;            # 3. Melhorar nomenclatura com padrões C4&#10;            if validation_results.get('best_practices', {}).get('follows_naming_conventions', False) == False:&#10;            if validation_results.get('best_practices', {}).get('follows_naming_conventions', False) == False:&#10;            if validation_results.get('best_practices', {}).get('follows_naming_conventions', False) == False:&#10;            if validation_results.get('best_practices', {}).get('follows_naming_conventions', False) == False:&#10;            if validation_results.get('best_practices', {}).get('follows_naming_conventions', False) == False:&#10;            if validation_results.get('best_practices', {}).get('follows_naming_conventions', False) == False:&#10;            if validation_results.get('best_practices', {}).get('follows_naming_conventions', False) == False:&#10;            if validation_results.get('best_practices', {}).get('follows_naming_conventions', False) == False:&#10;            if validation_results.get('best_practices', {}).get('follows_naming_conventions', False) == False:&#10;            if validation_results.get('best_practices', {}).get('follows_naming_conventions', False) == False:&#10;            if validation_results.get('best_practices', {}).get('follows_naming_conventions', False) == False:&#10;            if validation_results.get('best_practices', {}).get('follows_naming_conventions', False) == False:&#10;            if validation_results.get('best_practices', {}).get('follows_naming_conventions', False) == False:&#10;            if validation_results.get('best_practices', {}).get('follows_naming_conventions', False) == False:&#10;            if validation_results.get('best_practices', {}).get('follows_naming_conventions', False) == False:&#10;            if validation_results.get('best_practices', {}).get('follows_naming_conventions', False) == False:&#10;&#10;            # 7. Melhorar documentação com padrões C4&#10;            self._improve_c4_documentation(root)&#10;            improvements_applied.append(&quot;Documentação C4 aprimorada&quot;)&#10;&#10;            # 8. Validar e corrigir inconsistências&#10;            self._validate_and_fix_inconsistencies(root)&#10;            improvements_applied.append(&quot;Inconsistências corrigidas&quot;)&#10;&#10;            # Salvar diagrama melhorado&#10;            output_path = diagram_path.replace('.xml', '_quality_improved.xml')&#10;&#10;            # Registrar namespaces&#10;            for prefix, uri in self.namespaces.items():&#10;                ET.register_namespace(prefix, uri)&#10;&#10;            tree.write(output_path, encoding='utf-8', xml_declaration=True)&#10;&#10;            logger.info(f&quot;Diagrama melhorado salvo em: {output_path}&quot;)&#10;            logger.info(f&quot;Melhorias aplicadas: {', '.join(improvements_applied)}&quot;)&#10;&#10;            return output_path&#10;&#10;        except Exception as e:&#10;            logger.error(f&quot;Erro ao aplicar melhorias: {e}&quot;)&#10;            return diagram_path&#10;&#10;    def _optimize_container_structure(self, root: ET.Element):&#10;        &quot;&quot;&quot;Otimiza a estrutura específica para diagrama de container C4&quot;&quot;&quot;&#10;        &#10;        elements = root.findall('.//archimate:element', self.namespaces)&#10;        &#10;        # Categorizar elementos por tipo de container&#10;        containers = {&#10;            'user_interfaces': [],&#10;            'services': [],&#10;            'databases': [],&#10;            'external_systems': []&#10;        }&#10;        &#10;        for element in elements:&#10;            name_elem = element.find('archimate:name', self.namespaces)&#10;            if name_elem is not None:&#10;                name = name_elem.text.lower()&#10;                &#10;                if any(pattern in name for pattern in ['app', 'portal', 'ui', 'frontend']):&#10;                if any(pattern in name for pattern in ['app', 'portal', 'ui', 'frontend']):&#10;                if any(pattern in name for pattern in ['app', 'portal', 'ui', 'frontend']):&#10;                if any(pattern in name for pattern in ['app', 'portal', 'ui', 'frontend']):&#10;                if any(pattern in name for pattern in ['app', 'portal', 'ui', 'frontend']):&#10;                if any(pattern in name for pattern in ['app', 'portal', 'ui', 'frontend']):&#10;                if any(pattern in name for pattern in ['app', 'portal', 'ui', 'frontend']):&#10;                if any(pattern in name for pattern in ['app', 'portal', 'ui', 'frontend']):&#10;                if any(pattern in name for pattern in ['app', 'portal', 'ui', 'frontend']):&#10;                if any(pattern in name for pattern in ['app', 'portal', 'ui', 'frontend']):&#10;                if any(pattern in name for pattern in ['app', 'portal', 'ui', 'frontend']):&#10;                if any(pattern in name for pattern in ['app', 'portal', 'ui', 'frontend']):&#10;                if any(pattern in name for pattern in ['app', 'portal', 'ui', 'frontend']):&#10;                if any(pattern in name for pattern in ['app', 'portal', 'ui', 'frontend']):&#10;                if any(pattern in name for pattern in ['app', 'portal', 'ui', 'frontend']):&#10;                if any(pattern in name for pattern in ['app', 'portal', 'ui', 'frontend']):&#10;                elif any(pattern in name for pattern in ['service', 'api', 'gateway']):&#10;                elif any(pattern in name for pattern in ['service', 'api', 'gateway']):&#10;                elif any(pattern in name for pattern in ['database', 'db', 'storage']):&#10;                elif any(pattern in name for pattern in ['database', 'db', 'storage']):&#10;                elif any(pattern in name for pattern in ['external', 'bacen', 'third party']):&#10;                elif any(pattern in name for pattern in ['external', 'bacen', 'third party']):&#10;                name = name_elem.text.lower()&#10;                current_type = element.get('{http://www.w3.org/2001/XMLSchema-instance}type')&#10;                &#10;                # Determinar tipo correto baseado no nome e função&#10;                new_type = self._determine_optimal_element_type(name, current_type)&#10;                &#10;                if new_type != current_type:&#10;                    element.set('{http://www.w3.org/2001/XMLSchema-instance}type', new_type)&#10;                    logger.info(f&quot;Tipo atualizado para '{name_elem.text}': {current_type} -&gt; {new_type}&quot;)&#10;&#10;    def _determine_optimal_element_type(self, name: str, current_type: str) -&gt; str:&#10;        &quot;&quot;&quot;Determina o tipo ótimo de elemento ArchiMate para container C4&quot;&quot;&quot;&#10;        &#10;        name_lower = name.lower()&#10;        &#10;        # Mapeamento específico para containers C4&#10;        if any(pattern in name_lower for pattern in ['database', 'db', 'storage', 'repository']):&#10;        if any(pattern in name_lower for pattern in ['database', 'db', 'storage', 'repository']):&#10;        if any(pattern in name_lower for pattern in ['database', 'db', 'storage', 'repository']):&#10;        if any(pattern in name_lower for pattern in ['database', 'db', 'storage', 'repository']):&#10;        if any(pattern in name_lower for pattern in ['database', 'db', 'storage', 'repository']):&#10;        if any(pattern in name_lower for pattern in ['database', 'db', 'storage', 'repository']):&#10;        if any(pattern in name_lower for pattern in ['database', 'db', 'storage', 'repository']):&#10;        if any(pattern in name_lower for pattern in ['database', 'db', 'storage', 'repository']):&#10;        if any(pattern in name_lower for pattern in ['database', 'db', 'storage', 'repository']):&#10;        if any(pattern in name_lower for pattern in ['database', 'db', 'storage', 'repository']):&#10;        if any(pattern in name_lower for pattern in ['database', 'db', 'storage', 'repository']):&#10;        if any(pattern in name_lower for pattern in ['database', 'db', 'storage', 'repository']):&#10;        if any(pattern in name_lower for pattern in ['database', 'db', 'storage', 'repository']):&#10;        if any(pattern in name_lower for pattern in ['database', 'db', 'storage', 'repository']):&#10;        if any(pattern in name_lower for pattern in ['database', 'db', 'storage', 'repository']):&#10;        if any(pattern in name_lower for pattern in ['database', 'db', 'storage', 'repository']):&#10;        elif any(pattern in name_lower for pattern in ['service', 'api', 'microservice']):&#10;        elif any(pattern in name_lower for pattern in ['service', 'api', 'microservice']):&#10;        elif any(pattern in name_lower for pattern in ['gateway', 'proxy', 'router']):&#10;        elif any(pattern in name_lower for pattern in ['gateway', 'proxy', 'router']):&#10;        elif any(pattern in name_lower for pattern in ['app', 'portal', 'frontend', 'ui']):&#10;        elif any(pattern in name_lower for pattern in ['app', 'portal', 'frontend', 'ui']):&#10;        elif any(pattern in name_lower for pattern in ['external', 'third party', 'legacy']):&#10;        elif any(pattern in name_lower for pattern in ['external', 'third party', 'legacy']):&#10;        elif any(pattern in name_lower for pattern in ['external', 'third party', 'legacy']):&#10;        elif any(pattern in name_lower for pattern in ['queue', 'broker', 'event']):&#10;&#10;        &#10;            if not any(suffix in cleaned_name.lower() for suffix in ['database', 'db', 'storage']):&#10;        organizations_elem = root.find('organizations', self.namespaces)&#10;        if organizations_elem is None:&#10;            if not any(suffix in cleaned_name.lower() for suffix in ['database', 'db', 'storage']):&#10;&#10;        # Layers típicos de um container diagram&#10;            if not any(suffix in cleaned_name.lower() for suffix in ['database', 'db', 'storage']):&#10;            ('presentation', 'Presentation Layer', 'User interfaces and presentation logic'),&#10;            ('application', 'Application Layer', 'Application services and business logic'),&#10;            if not any(suffix in cleaned_name.lower() for suffix in ['database', 'db', 'storage']):&#10;            ('data', 'Data Layer', 'Data storage and persistence')&#10;        ]&#10;            if not any(suffix in cleaned_name.lower() for suffix in ['database', 'db', 'storage']):&#10;        for layer_id, layer_name, layer_desc in layers:&#10;            self._create_layer_organization(organizations_elem, layer_id, layer_name, layer_desc)&#10;            if not any(suffix in cleaned_name.lower() for suffix in ['database', 'db', 'storage']):&#10;    def _create_layer_organization(self, parent: ET.Element, layer_id: str, name: str, description: str):&#10;        &quot;&quot;&quot;Cria uma organização de layer&quot;&quot;&quot;&#10;            if not any(suffix in cleaned_name.lower() for suffix in ['database', 'db', 'storage']):&#10;        org_elem = ET.SubElement(parent, 'item')&#10;        org_elem.set('identifier', f'org-{layer_id}')&#10;            if not any(suffix in cleaned_name.lower() for suffix in ['database', 'db', 'storage']):&#10;        name_elem = ET.SubElement(org_elem, 'name')&#10;        name_elem.text = name&#10;            if not any(suffix in cleaned_name.lower() for suffix in ['database', 'db', 'storage']):&#10;        &#10;        doc_elem = ET.SubElement(org_elem, 'documentation')&#10;            if not any(suffix in cleaned_name.lower() for suffix in ['database', 'db', 'storage']):&#10;        doc_elem.set('{http://www.w3.org/XML/1998/namespace}lang', 'pt-br')&#10;&#10;            if not any(suffix in cleaned_name.lower() for suffix in ['database', 'db', 'storage']):&#10;        &quot;&quot;&quot;Aprimora relacionamentos com padrões C4&quot;&quot;&quot;&#10;        &#10;            if not any(suffix in cleaned_name.lower() for suffix in ['database', 'db', 'storage']):&#10;        elements = {elem.get('identifier'): elem for elem in root.findall('.//archimate:element', self.namespaces)}&#10;        &#10;            if not any(suffix in cleaned_name.lower() for suffix in ['gateway', 'api', 'interface']):&#10;            source_id = rel.get('source')&#10;            target_id = rel.get('target')&#10;            &#10;            if source_id in elements and target_id in elements:&#10;                source_elem = elements[source_id]&#10;                target_elem = elements[target_id]&#10;                &#10;                # Determinar tipo de relacionamento otimizado&#10;                optimal_rel_type = self._determine_optimal_relationship_type(source_elem, target_elem)&#10;                current_type = rel.get('{http://www.w3.org/2001/XMLSchema-instance}type')&#10;                &#10;                if optimal_rel_type != current_type:&#10;                    rel.set('{http://www.w3.org/2001/XMLSchema-instance}type', optimal_rel_type)&#10;&#10;    def _determine_optimal_relationship_type(self, source: ET.Element, target: ET.Element) -&gt; str:&#10;        &quot;&quot;&quot;Determina tipo ótimo de relacionamento entre containers&quot;&quot;&quot;&#10;        &#10;        source_type = source.get('{http://www.w3.org/2001/XMLSchema-instance}type')&#10;        target_type = target.get('{http://www.w3.org/2001/XMLSchema-instance}type')&#10;        &#10;        # Padrões de relacionamento C4&#10;        if source_type == 'ApplicationComponent' and target_type == 'ApplicationService':&#10;            return 'Access'&#10;        elif source_type == 'ApplicationInterface' and target_type == 'ApplicationService':&#10;        if source_type == 'ApplicationComponent' and target_type == 'ApplicationService':&#10;            return 'Access'&#10;        &#10;        if source_type == 'ApplicationComponent' and target_type == 'ApplicationService':&#10;            return 'Access'&#10;&#10;        if source_type == 'ApplicationComponent' and target_type == 'ApplicationService':&#10;            return 'Access'&#10;&#10;        if source_type == 'ApplicationComponent' and target_type == 'ApplicationService':&#10;            return 'Access'&#10;            if name_elem is not None:&#10;        if source_type == 'ApplicationComponent' and target_type == 'ApplicationService':&#10;            return 'Access'&#10;" />
              <option name="updatedContent" value="&quot;&quot;&quot;&#10;Aplicador de Melhorias de Qualidade C4&#10;Implementa automaticamente as recomendações da validação de qualidade&#10;Versão otimizada para diagramas de container C4&#10;&quot;&quot;&quot;&#10;&#10;import xml.etree.ElementTree as ET&#10;from pathlib import Path&#10;from typing import Dict, List, Optional, Set&#10;import logging&#10;import re&#10;from .naming_conventions import NamingConventionApplier, apply_naming_improvements&#10;&#10;logger = logging.getLogger(__name__)&#10;&#10;class C4QualityImprover:&#10;    &quot;&quot;&quot;Aplica melhorias automáticas baseadas na validação de qualidade&quot;&quot;&quot;&#10;&#10;    def __init__(self):&#10;        self.naming_applier = NamingConventionApplier()&#10;        self.namespaces = {&#10;            'archimate': 'http://www.opengroup.org/xsd/archimate/3.0/',&#10;            'dc': 'http://purl.org/dc/elements/1.1/',&#10;            'xsi': 'http://www.w3.org/2001/XMLSchema-instance'&#10;        }&#10;        &#10;        # Padrões C4 para container diagram&#10;        self.c4_container_patterns = {&#10;            'web_app': ['Web App', 'Portal', 'Frontend', 'UI', 'SPA'],&#10;            'mobile_app': ['Mobile', 'App', 'Android', 'iOS'],&#10;            'api_gateway': ['Gateway', 'API Gateway', 'Proxy', 'Router'],&#10;            'microservice': ['Service', 'Microservice', 'Component', 'API'],&#10;            'batch_process': ['Job', 'Batch', 'Task', 'Scheduler'],&#10;            'database': ['Database', 'DB', 'Storage', 'Repository'],&#10;            'message_queue': ['Queue', 'Broker', 'Event Bus', 'Kafka', 'RabbitMQ'],&#10;            'external_system': ['External', 'Third Party', 'Legacy', 'Bacen']&#10;        }&#10;&#10;    def improve_diagram(self, diagram_path: str, validation_results: Dict) -&gt; str:&#10;        &quot;&quot;&quot;Aplica melhorias ao diagrama baseadas nos resultados da validação&quot;&quot;&quot;&#10;&#10;        try:&#10;            tree = ET.parse(diagram_path)&#10;            root = tree.getroot()&#10;&#10;            improvements_applied = []&#10;&#10;            # 1. Otimizações específicas para Container Diagram&#10;            self._optimize_container_structure(root)&#10;            improvements_applied.append(&quot;Estrutura de container otimizada&quot;)&#10;&#10;            # 2. Aplicar tipos corretos de elementos C4&#10;            self._apply_c4_element_types(root)&#10;            improvements_applied.append(&quot;Tipos de elementos C4 aplicados&quot;)&#10;&#10;            # 3. Melhorar nomenclatura com padrões C4&#10;            if not validation_results.get('best_practices', {}).get('follows_naming_conventions', False):&#10;                self._improve_c4_naming_conventions(root)&#10;                improvements_applied.append(&quot;Convenções de nomenclatura C4 aplicadas&quot;)&#10;&#10;            # 4. Organizar em layers arquiteturais&#10;            if not validation_results.get('structure_analysis', {}).get('has_organizations', False):&#10;                self._add_architectural_layers(root)&#10;                improvements_applied.append(&quot;Layers arquiteturais adicionados&quot;)&#10;&#10;            # 5. Melhorar relacionamentos C4&#10;            self._enhance_c4_relationships(root)&#10;            improvements_applied.append(&quot;Relacionamentos C4 aprimorados&quot;)&#10;&#10;            # 6. Adicionar boundaries e groupings&#10;            self._add_c4_boundaries(root)&#10;            improvements_applied.append(&quot;Boundaries C4 adicionados&quot;)&#10;&#10;            # 7. Melhorar documentação com padrões C4&#10;            self._improve_c4_documentation(root)&#10;            improvements_applied.append(&quot;Documentação C4 aprimorada&quot;)&#10;&#10;            # 8. Validar e corrigir inconsistências&#10;            self._validate_and_fix_inconsistencies(root)&#10;            improvements_applied.append(&quot;Inconsistências corrigidas&quot;)&#10;&#10;            # Salvar diagrama melhorado&#10;            output_path = diagram_path.replace('.xml', '_quality_improved.xml')&#10;&#10;            # Registrar namespaces&#10;            for prefix, uri in self.namespaces.items():&#10;                ET.register_namespace(prefix, uri)&#10;&#10;            tree.write(output_path, encoding='utf-8', xml_declaration=True)&#10;&#10;            logger.info(f&quot;Diagrama melhorado salvo em: {output_path}&quot;)&#10;            logger.info(f&quot;Melhorias aplicadas: {', '.join(improvements_applied)}&quot;)&#10;&#10;            return output_path&#10;&#10;        except Exception as e:&#10;            logger.error(f&quot;Erro ao aplicar melhorias: {e}&quot;)&#10;            return diagram_path&#10;&#10;    def _optimize_container_structure(self, root: ET.Element):&#10;        &quot;&quot;&quot;Otimiza a estrutura específica para diagrama de container C4&quot;&quot;&quot;&#10;        &#10;        elements = root.findall('.//archimate:element', self.namespaces)&#10;        &#10;        # Categorizar elementos por tipo de container&#10;        containers = {&#10;            'user_interfaces': [],&#10;            'services': [],&#10;            'databases': [],&#10;            'external_systems': []&#10;        }&#10;        &#10;        for element in elements:&#10;            name_elem = element.find('archimate:name', self.namespaces)&#10;            if name_elem is not None:&#10;                name = name_elem.text.lower()&#10;                &#10;                if any(pattern.lower() in name for pattern in self.c4_container_patterns['web_app'] + self.c4_container_patterns['mobile_app']):&#10;                    containers['user_interfaces'].append(element)&#10;                elif any(pattern.lower() in name for pattern in self.c4_container_patterns['microservice'] + self.c4_container_patterns['api_gateway']):&#10;                    containers['services'].append(element)&#10;                elif any(pattern.lower() in name for pattern in self.c4_container_patterns['database']):&#10;                    containers['databases'].append(element)&#10;                elif any(pattern.lower() in name for pattern in self.c4_container_patterns['external_system']):&#10;                    containers['external_systems'].append(element)&#10;&#10;        # Adicionar propriedades específicas por categoria&#10;        for category, elements_list in containers.items():&#10;            for element in elements_list:&#10;                self._add_container_properties(element, category)&#10;&#10;    def _apply_c4_element_types(self, root: ET.Element):&#10;        &quot;&quot;&quot;Aplica tipos corretos de elementos ArchiMate para containers C4&quot;&quot;&quot;&#10;        &#10;        elements = root.findall('.//archimate:element', self.namespaces)&#10;        &#10;        for element in elements:&#10;            name_elem = element.find('archimate:name', self.namespaces)&#10;            if name_elem is not None:&#10;                name = name_elem.text.lower()&#10;                current_type = element.get('{http://www.w3.org/2001/XMLSchema-instance}type')&#10;                &#10;                # Determinar tipo correto baseado no nome e função&#10;                new_type = self._determine_optimal_element_type(name, current_type)&#10;                &#10;                if new_type != current_type:&#10;                    element.set('{http://www.w3.org/2001/XMLSchema-instance}type', new_type)&#10;                    logger.info(f&quot;Tipo atualizado para '{name_elem.text}': {current_type} -&gt; {new_type}&quot;)&#10;&#10;    def _determine_optimal_element_type(self, name: str, current_type: str) -&gt; str:&#10;        &quot;&quot;&quot;Determina o tipo ótimo de elemento ArchiMate para container C4&quot;&quot;&quot;&#10;        &#10;        name_lower = name.lower()&#10;        &#10;        # Mapeamento específico para containers C4&#10;        if any(pattern.lower() in name_lower for pattern in self.c4_container_patterns['database']):&#10;            return 'DataObject'&#10;        elif any(pattern.lower() in name_lower for pattern in self.c4_container_patterns['microservice']):&#10;            return 'ApplicationService'&#10;        elif any(pattern.lower() in name_lower for pattern in self.c4_container_patterns['api_gateway']):&#10;            return 'ApplicationInterface'&#10;        elif any(pattern.lower() in name_lower for pattern in self.c4_container_patterns['web_app'] + self.c4_container_patterns['mobile_app']):&#10;            return 'ApplicationComponent'&#10;        elif any(pattern.lower() in name_lower for pattern in self.c4_container_patterns['external_system']):&#10;            return 'ApplicationComponent' # Representado como componente, mas com propriedades específicas&#10;        elif any(pattern.lower() in name_lower for pattern in self.c4_container_patterns['message_queue']):&#10;            return 'ApplicationEvent'&#10;        elif any(pattern.lower() in name_lower for pattern in self.c4_container_patterns['batch_process']):&#10;            return 'ApplicationProcess'&#10;        else:&#10;            return current_type  # Manter tipo atual se não identificado&#10;&#10;    def _improve_c4_naming_conventions(self, root: ET.Element):&#10;        &quot;&quot;&quot;Aplica convenções de nomenclatura específicas para C4&quot;&quot;&quot;&#10;        &#10;        elements = root.findall('.//archimate:element', self.namespaces)&#10;&#10;        for element in elements:&#10;            name_elem = element.find('archimate:name', self.namespaces)&#10;            if name_elem is not None:&#10;                original_name = name_elem.text&#10;                element_type = element.get('{http://www.w3.org/2001/XMLSchema-instance}type')&#10;&#10;                # Aplicar convenção C4 específica&#10;                improved_name = self._apply_c4_naming_pattern(original_name, element_type)&#10;&#10;                if improved_name != original_name:&#10;                    name_elem.text = improved_name&#10;                    element.set('original-name', original_name)&#10;                    logger.info(f&quot;Nome C4 atualizado: '{original_name}' -&gt; '{improved_name}'&quot;)&#10;&#10;    def _apply_c4_naming_pattern(self, name: str, element_type: str) -&gt; str:&#10;        &quot;&quot;&quot;Aplica padrões de nomenclatura C4&quot;&quot;&quot;&#10;        &#10;        # Remover prefixos/sufixos desnecessários&#10;        cleaned_name = re.sub(r'^(Sistema|System|Serviço|Service)\s+', '', name, flags=re.IGNORECASE)&#10;        cleaned_name = re.sub(r'\s+(Sistema|System|Serviço|Service)$', '', cleaned_name, flags=re.IGNORECASE)&#10;        &#10;        # Aplicar padrões específicos por tipo&#10;        if element_type == 'ApplicationService':&#10;            if not cleaned_name.endswith('Service') and not cleaned_name.endswith('API'):&#10;                cleaned_name = f&quot;{cleaned_name} Service&quot;&#10;        elif element_type == 'DataObject':&#10;            if not any(suffix.lower() in cleaned_name.lower() for suffix in ['database', 'db', 'storage']):&#10;                cleaned_name = f&quot;{cleaned_name} Database&quot;&#10;        elif element_type == 'ApplicationInterface':&#10;            if not any(suffix.lower() in cleaned_name.lower() for suffix in ['gateway', 'api', 'interface']):&#10;                cleaned_name = f&quot;{cleaned_name} Gateway&quot;&#10;        &#10;        # Capitalizar adequadamente&#10;        return ' '.join(word.capitalize() for word in cleaned_name.split())&#10;&#10;    def _add_architectural_layers(self, root: ET.Element):&#10;        &quot;&quot;&quot;Adiciona organização em layers arquiteturais para C4&quot;&quot;&quot;&#10;        &#10;        # Criar organizations para layers C4&#10;        organizations_elem = root.find('organizations', self.namespaces)&#10;        if organizations_elem is None:&#10;            organizations_elem = ET.SubElement(root, 'organizations')&#10;&#10;        # Layers típicos de um container diagram&#10;        layers = [&#10;            ('presentation', 'Presentation Layer', 'User interfaces and presentation logic'),&#10;            ('application', 'Application Layer', 'Application services and business logic'),&#10;            ('integration', 'Integration Layer', 'External system integrations'),&#10;            ('data', 'Data Layer', 'Data storage and persistence')&#10;        ]&#10;&#10;        for layer_id, layer_name, layer_desc in layers:&#10;            self._create_layer_organization(organizations_elem, layer_id, layer_name, layer_desc)&#10;&#10;    def _create_layer_organization(self, parent: ET.Element, layer_id: str, name: str, description: str):&#10;        &quot;&quot;&quot;Cria uma organização de layer&quot;&quot;&quot;&#10;        &#10;        org_elem = ET.SubElement(parent, 'item')&#10;        org_elem.set('identifier', f'org-{layer_id}')&#10;        &#10;        name_elem = ET.SubElement(org_elem, 'name')&#10;        name_elem.text = name&#10;        name_elem.set('{http://www.w3.org/XML/1998/namespace}lang', 'pt-br')&#10;        &#10;        doc_elem = ET.SubElement(org_elem, 'documentation')&#10;        doc_elem.text = description&#10;        doc_elem.set('{http://www.w3.org/XML/1998/namespace}lang', 'pt-br')&#10;&#10;    def _enhance_c4_relationships(self, root: ET.Element):&#10;        &quot;&quot;&quot;Aprimora relacionamentos com padrões C4&quot;&quot;&quot;&#10;        &#10;        relationships = root.findall('.//archimate:relationship', self.namespaces)&#10;        elements = {elem.get('identifier'): elem for elem in root.findall('.//archimate:element', self.namespaces)}&#10;        &#10;        for rel in relationships:&#10;            source_id = rel.get('source')&#10;            target_id = rel.get('target')&#10;            &#10;            if source_id in elements and target_id in elements:&#10;                source_elem = elements[source_id]&#10;                target_elem = elements[target_id]&#10;                &#10;                # Determinar tipo de relacionamento otimizado&#10;                optimal_rel_type = self._determine_optimal_relationship_type(source_elem, target_elem)&#10;                current_type = rel.get('{http://www.w3.org/2001/XMLSchema-instance}type')&#10;                &#10;                if optimal_rel_type != current_type:&#10;                    rel.set('{http://www.w3.org/2001/XMLSchema-instance}type', optimal_rel_type)&#10;&#10;    def _determine_optimal_relationship_type(self, source: ET.Element, target: ET.Element) -&gt; str:&#10;        &quot;&quot;&quot;Determina tipo ótimo de relacionamento entre containers&quot;&quot;&quot;&#10;        &#10;        source_type = source.get('{http://www.w3.org/2001/XMLSchema-instance}type')&#10;        target_type = target.get('{http://www.w3.org/2001/XMLSchema-instance}type')&#10;        source_name = source.find('archimate:name', self.namespaces).text&#10;        target_name = target.find('archimate:name', self.namespaces).text&#10;        &#10;        # Padrões de relacionamento C4&#10;        if target_type == 'ApplicationEvent': # Producer -&gt; Queue&#10;            return 'Triggering'&#10;        if source_type == 'ApplicationEvent': # Queue -&gt; Consumer&#10;            return 'Triggering'&#10;        if source_type == 'ApplicationComponent' and target_type in ['ApplicationService', 'ApplicationInterface']:&#10;            return 'Triggering' # UI/Mobile -&gt; Backend&#10;        elif source_type == 'ApplicationService' and target_type == 'DataObject':&#10;            return 'Access' # Service -&gt; DB&#10;        elif source_type == 'ApplicationInterface' and target_type == 'ApplicationService':&#10;            return 'Serving' # Gateway -&gt; Service&#10;        elif any(pattern.lower() in target_name.lower() for pattern in self.c4_container_patterns['external_system']):&#10;            return 'Flow' # Service -&gt; External System&#10;        elif any(pattern.lower() in source_name.lower() for pattern in self.c4_container_patterns['external_system']):&#10;            return 'Flow' # External System -&gt; Service&#10;        else:&#10;            return 'Flow'  # Padrão para comunicação entre containers (e.g. service-to-service)&#10;&#10;    def _add_c4_boundaries(self, root: ET.Element):&#10;        &quot;&quot;&quot;Adiciona boundaries visuais para containers C4&quot;&quot;&quot;&#10;        &#10;        # Criar groupings para boundaries&#10;        views_elem = root.find('views', self.namespaces)&#10;        if views_elem is None:&#10;            views_elem = ET.SubElement(root, 'views')&#10;        &#10;        # Adicionar boundary para sistema principal&#10;        self._create_system_boundary(views_elem)&#10;        &#10;        # Adicionar boundaries para subsistemas&#10;        self._create_subsystem_boundaries(views_elem, root)&#10;&#10;    def _create_system_boundary(self, views_elem: ET.Element):&#10;        &quot;&quot;&quot;Cria boundary do sistema principal&quot;&quot;&quot;&#10;        &#10;        boundary = ET.SubElement(views_elem, 'diagrams')&#10;        boundary.set('identifier', 'system-boundary')&#10;        boundary.set('{http://www.w3.org/2001/XMLSchema-instance}type', 'Grouping')&#10;        &#10;        name_elem = ET.SubElement(boundary, 'name')&#10;        name_elem.text = 'Sistema Principal'&#10;        name_elem.set('{http://www.w3.org/XML/1998/namespace}lang', 'pt-br')&#10;&#10;    def _add_container_properties(self, element: ET.Element, category: str):&#10;        &quot;&quot;&quot;Adiciona propriedades específicas por categoria de container&quot;&quot;&quot;&#10;        &#10;        # Adicionar propriedades baseadas na categoria&#10;        properties = {&#10;            'user_interfaces': {&#10;                'layer': 'presentation',&#10;                'technology': 'Web/Mobile UI',&#10;                'responsibility': 'User interaction and presentation'&#10;            },&#10;            'services': {&#10;                'layer': 'application',&#10;                'technology': 'Microservice/API',&#10;                'responsibility': 'Business logic and processing'&#10;            },&#10;            'databases': {&#10;                'layer': 'data',&#10;                'technology': 'Database',&#10;                'responsibility': 'Data persistence and storage'&#10;            },&#10;            'external_systems': {&#10;                'layer': 'integration',&#10;                'technology': 'External System',&#10;                'responsibility': 'External integration point'&#10;            }&#10;        }&#10;        &#10;        if category in properties:&#10;            props = properties[category]&#10;            &#10;            # Adicionar como propriedades do elemento&#10;            props_elem = element.find('archimate:properties', self.namespaces)&#10;            if props_elem is None:&#10;                props_elem = ET.SubElement(element, 'properties')&#10;            &#10;            for key, value in props.items():&#10;                prop_elem = ET.SubElement(props_elem, 'property')&#10;                prop_elem.set('key', key)&#10;                prop_elem.set('value', value)&#10;&#10;    def _create_subsystem_boundaries(self, views_elem: ET.Element, root: ET.Element):&#10;        &quot;&quot;&quot;Cria boundaries para subsistemas&quot;&quot;&quot;&#10;        &#10;        elements = root.findall('.//archimate:element', self.namespaces)&#10;        &#10;        # Agrupar elementos por subsistema baseado no nome&#10;        subsystems = {}&#10;        for element in elements:&#10;            name_elem = element.find('archimate:name', self.namespaces)&#10;            if name_elem is not None:&#10;                name = name_elem.text&#10;                &#10;                # Identificar subsistema baseado em padrões&#10;                subsystem = self._identify_subsystem(name)&#10;                if subsystem not in subsystems:&#10;                    subsystems[subsystem] = []&#10;                subsystems[subsystem].append(element.get('identifier'))&#10;        &#10;        # Criar boundary para cada subsistema&#10;        for subsystem_name, element_ids in subsystems.items():&#10;            if len(element_ids) &gt; 1:  # Só criar boundary se houver mais de um elemento&#10;                self._create_subsystem_boundary(views_elem, subsystem_name, element_ids)&#10;&#10;    def _identify_subsystem(self, name: str) -&gt; str:&#10;        &quot;&quot;&quot;Identifica o subsistema baseado no nome do elemento&quot;&quot;&quot;&#10;        &#10;        name_lower = name.lower()&#10;        &#10;        if any(pattern in name_lower for pattern in ['banking', 'account', 'payment']):&#10;            return 'Banking Core'&#10;        elif any(pattern in name_lower for pattern in ['security', 'auth', 'validation']):&#10;            return 'Security'&#10;        elif any(pattern in name_lower for pattern in ['notification', 'message', 'alert']):&#10;            return 'Communication'&#10;        elif any(pattern in name_lower for pattern in ['integration', 'gateway', 'api']):&#10;            return 'Integration'&#10;        elif any(pattern in name_lower for pattern in ['analytics', 'report', 'dashboard']):&#10;            return 'Analytics'&#10;        elif any(pattern in name_lower for pattern in ['logging', 'monitoring', 'tracing']):&#10;            return 'Monitoring'&#10;        elif any(pattern in name_lower for pattern in self.c4_container_patterns['external_system']):&#10;            return 'External Systems'&#10;        else:&#10;            return 'Core System'&#10;&#10;    def _create_subsystem_boundary(self, views_elem: ET.Element, subsystem_name: str, element_ids: List[str]):&#10;        &quot;&quot;&quot;Cria boundary para um subsistema específico&quot;&quot;&quot;&#10;        &#10;        boundary = ET.SubElement(views_elem, 'diagrams')&#10;        boundary.set('identifier', f'boundary-{subsystem_name.lower().replace(&quot; &quot;, &quot;-&quot;)}')&#10;        boundary.set('{http://www.w3.org/2001/XMLSchema-instance}type', 'Grouping')&#10;        &#10;        name_elem = ET.SubElement(boundary, 'name')&#10;        name_elem.text = f'{subsystem_name} Boundary'&#10;        name_elem.set('{http://www.w3.org/XML/1998/namespace}lang', 'pt-br')&#10;        &#10;        # Adicionar elementos ao boundary&#10;        for elem_id in element_ids:&#10;            ref_elem = ET.SubElement(boundary, 'elementRef')&#10;            ref_elem.set('ref', elem_id)&#10;&#10;    def _improve_c4_documentation(self, root: ET.Element):&#10;        &quot;&quot;&quot;Melhora documentação com padrões C4&quot;&quot;&quot;&#10;        &#10;        elements = root.findall('.//archimate:element', self.namespaces)&#10;        &#10;        for element in elements:&#10;            doc_elem = element.find('archimate:documentation', self.namespaces)&#10;            name_elem = element.find('archimate:name', self.namespaces)&#10;            element_type = element.get('{http://www.w3.org/2001/XMLSchema-instance}type')&#10;            &#10;            if name_elem is not None:&#10;                name = name_elem.text&#10;                &#10;                # Gerar documentação C4 específica&#10;                c4_documentation = self._generate_c4_documentation(name, element_type)&#10;                &#10;                if doc_elem is None:&#10;                    doc_elem = ET.SubElement(element, 'documentation')&#10;                    doc_elem.set('{http://www.w3.org/XML/1998/namespace}lang', 'pt-br')&#10;                &#10;                # Melhorar documentação existente ou criar nova&#10;                current_doc = doc_elem.text or &quot;&quot;&#10;                if len(current_doc) &lt; 50:  # Documentação insuficiente&#10;                    doc_elem.text = c4_documentation&#10;&#10;    def _generate_c4_documentation(self, name: str, element_type: str) -&gt; str:&#10;        &quot;&quot;&quot;Gera documentação seguindo padrões C4&quot;&quot;&quot;&#10;        &#10;        templates = {&#10;            'ApplicationComponent': f&quot;Container: {name} (Software System)\nResponsabilidade: Fornece funcionalidades de interface com o usuário. Pode ser uma aplicação web, mobile, desktop, etc.\nTecnologia: [Framework UI, e.g., React, Angular, Swift, Kotlin]\nInterações: Descreve como o usuário interage com o sistema e quais APIs são chamadas.&quot;,&#10;            'ApplicationService': f&quot;Container: {name} (API/Microservice)\nResponsabilidade: Expõe uma API para encapsular lógica de negócio, regras e acesso a dados.\nTecnologia: [Linguagem/Framework, e.g., Java/Spring, Python/Django, Node.js/Express]\nAPIs: [Listar endpoints principais, e.g., REST, gRPC, GraphQL].&quot;,&#10;            'DataObject': f&quot;Container: {name} (Database/Storage)\nResponsabilidade: Fornece um mecanismo de persistência de dados para um ou mais contêineres.\nTecnologia: [Sistema de banco de dados, e.g., PostgreSQL, MongoDB, S3]\nEsquema: [Principais entidades de dados armazenadas].&quot;,&#10;            'ApplicationInterface': f&quot;Container: {name} (API Gateway)\nResponsabilidade: Roteia requisições para os serviços apropriados, podendo lidar com autenticação, logging e rate limiting.\nTecnologia: [e.g., NGINX, Apigee, Kong]\nProtocolos: [HTTP, REST, GraphQL, etc.].&quot;,&#10;            'ApplicationEvent': f&quot;Container: {name} (Message Bus/Queue)\nResponsabilidade: Permite comunicação assíncrona entre contêineres, desacoplando produtores e consumidores.\nTecnologia: [e.g., Kafka, RabbitMQ, Google Pub/Sub]\nTópicos/Eventos: [Principais eventos ou tópicos publicados/consumidos].&quot;,&#10;            'ApplicationProcess': f&quot;Container: {name} (Batch Process)\nResponsabilidade: Executa tarefas em lote, agendadas ou sob demanda, como relatórios ou processamento de dados.\nTecnologia: [e.g., Spring Batch, Cron Job, Airflow]\nTriggers: [Eventos que disparam o processo].&quot;&#10;        }&#10;        &#10;        return templates.get(element_type, f&quot;Container: {name}\nResponsabilidade: [A ser definida]\nTecnologia: [A ser definida]&quot;)&#10;&#10;    def _validate_and_fix_inconsistencies(self, root: ET.Element):&#10;        &quot;&quot;&quot;Valida e corrige inconsistências no diagrama C4&quot;&quot;&quot;&#10;        &#10;        # Verificar elementos órfãos (sem relacionamentos)&#10;        self._fix_orphaned_elements(root)&#10;        &#10;        # Verificar relacionamentos bidirecionais desnecessários&#10;        self._fix_redundant_relationships(root)&#10;        &#10;        # Verificar nomenclatura consistente&#10;        self._fix_naming_inconsistencies(root)&#10;&#10;    def _fix_orphaned_elements(self, root: ET.Element):&#10;        &quot;&quot;&quot;Corrige elementos sem relacionamentos&quot;&quot;&quot;&#10;        &#10;        elements = root.findall('.//archimate:element', self.namespaces)&#10;        relationships = root.findall('.//archimate:relationship', self.namespaces)&#10;        &#10;        # Identificar elementos conectados&#10;        connected_elements = set()&#10;        for rel in relationships:&#10;            connected_elements.add(rel.get('source'))&#10;            connected_elements.add(rel.get('target'))&#10;        &#10;        # Identificar elementos órfãos&#10;        for element in elements:&#10;            elem_id = element.get('identifier')&#10;            if elem_id not in connected_elements:&#10;                element_name = element.find('archimate:name', self.namespaces).text&#10;                logger.warning(f&quot;Elemento órfão encontrado: {element_name}&quot;)&#10;                # Tenta corrigir heuristicamente&#10;                self._heuristically_fix_orphan(root, element, elements)&#10;&#10;&#10;    def _fix_redundant_relationships(self, root: ET.Element):&#10;        &quot;&quot;&quot;Remove relacionamentos redundantes ou bidirecionais desnecessários&quot;&quot;&quot;&#10;        &#10;        relationships = root.findall('.//archimate:relationship', self.namespaces)&#10;        relationships_parent = relationships[0].getparent() if relationships else None&#10;        &#10;        if not relationships_parent:&#10;            return&#10;        &#10;        # Identificar relacionamentos duplicados ou redundantes&#10;        relationship_pairs = set()&#10;        redundant_relationships = []&#10;        &#10;        for rel in relationships:&#10;            source = rel.get('source')&#10;            target = rel.get('target')&#10;            rel_type = rel.get('{http://www.w3.org/2001/XMLSchema-instance}type')&#10;            &#10;            # Criar chave única para o relacionamento&#10;            pair_key = tuple(sorted([source, target])) + (rel_type,)&#10;            &#10;            if pair_key in relationship_pairs:&#10;                redundant_relationships.append(rel)&#10;            else:&#10;                relationship_pairs.add(pair_key)&#10;        &#10;        # Remover relacionamentos redundantes&#10;        for rel in redundant_relationships:&#10;            relationships_parent.remove(rel)&#10;            logger.info(f&quot;Relacionamento redundante removido: {rel.get('source')} -&gt; {rel.get('target')}&quot;)&#10;&#10;    def _heuristically_fix_orphan(self, root: ET.Element, orphan: ET.Element, all_elements: List[ET.Element]):&#10;        &quot;&quot;&quot;Tenta conectar um elemento órfão a outro elemento baseado em heurísticas&quot;&quot;&quot;&#10;        orphan_type = orphan.get('{http://www.w3.org/2001/XMLSchema-instance}type')&#10;        orphan_name = orphan.find('archimate:name', self.namespaces).text&#10;&#10;        # Heurística 1: Conectar banco de dados a um serviço com nome similar&#10;        if orphan_type == 'DataObject':&#10;            best_match_service = self._find_best_match_for_db(orphan_name, all_elements)&#10;            if best_match_service:&#10;                self._create_relationship(root, best_match_service.get('identifier'), orphan.get('identifier'), 'Access')&#10;                logger.info(f&quot;Elemento órfão '{orphan_name}' conectado heuristicamente ao serviço '{best_match_service.find('archimate:name', self.namespaces).text}'&quot;)&#10;                return&#10;&#10;        # Heurística 2: Conectar serviço a um API Gateway, se existir&#10;        if orphan_type == 'ApplicationService':&#10;            api_gateway = self._find_element_by_type(all_elements, 'ApplicationInterface')&#10;            if api_gateway:&#10;                self._create_relationship(root, api_gateway.get('identifier'), orphan.get('identifier'), 'Serving')&#10;                logger.info(f&quot;Elemento órfão '{orphan_name}' conectado heuristicamente ao API Gateway '{api_gateway.find('archimate:name', self.namespaces).text}'&quot;)&#10;                return&#10;&#10;    def _find_best_match_for_db(self, db_name: str, elements: List[ET.Element]) -&gt; Optional[ET.Element]:&#10;        &quot;&quot;&quot;Encontra o serviço mais provável para um determinado banco de dados&quot;&quot;&quot;&#10;        db_name_base = db_name.lower().replace('database', '').replace('db', '').strip()&#10;        &#10;        best_match = None&#10;        highest_score = 0&#10;&#10;        for element in elements:&#10;            if element.get('{http://www.w3.org/2001/XMLSchema-instance}type') == 'ApplicationService':&#10;                service_name = element.find('archimate:name', self.namespaces).text.lower()&#10;                if db_name_base in service_name:&#10;                    # Simple match score&#10;                    score = len(db_name_base)&#10;                    if score &gt; highest_score:&#10;                        highest_score = score&#10;                        best_match = element&#10;        return best_match&#10;&#10;    def _find_element_by_type(self, elements: List[ET.Element], element_type: str) -&gt; Optional[ET.Element]:&#10;        &quot;&quot;&quot;Encontra o primeiro elemento de um determinado tipo&quot;&quot;&quot;&#10;        for element in elements:&#10;            if element.get('{http://www.w3.org/2001/XMLSchema-instance}type') == element_type:&#10;                return element&#10;        return None&#10;&#10;    def _create_relationship(self, root: ET.Element, source_id: str, target_id: str, rel_type: str):&#10;        &quot;&quot;&quot;Cria um novo relacionamento no modelo&quot;&quot;&quot;&#10;        relationships_elem = root.find('relationships', self.namespaces)&#10;        if relationships_elem is None:&#10;            relationships_elem = ET.SubElement(root, 'relationships')&#10;&#10;        new_rel = ET.SubElement(relationships_elem, 'relationship')&#10;        new_rel.set('identifier', f'rel-{source_id}-{target_id}')&#10;        new_rel.set('source', source_id)&#10;        new_rel.set('target', target_id)&#10;        new_rel.set('{http://www.w3.org/2001/XMLSchema-instance}type', rel_type)&#10;        logger.info(f&quot;Novo relacionamento criado: {source_id} -&gt; {target_id} (type: {rel_type})&quot;)&#10;&#10;    def _fix_naming_inconsistencies(self, root: ET.Element):&#10;        &quot;&quot;&quot;Corrige inconsistências na nomenclatura&quot;&quot;&quot;&#10;        &#10;        elements = root.findall('.//archimate:element', self.namespaces)&#10;        &#10;        # Mapear nomes similares&#10;        name_groups = {}&#10;        for element in elements:&#10;            name_elem = element.find('archimate:name', self.namespaces)&#10;            if name_elem is not None:&#10;                name = name_elem.text&#10;                &#10;                # Normalizar nome para agrupamento&#10;                normalized = self._normalize_name_for_grouping(name)&#10;                &#10;                if normalized not in name_groups:&#10;                    name_groups[normalized] = []&#10;                name_groups[normalized].append((element, name))&#10;        &#10;        # Corrigir grupos com nomes similares&#10;        for normalized, group in name_groups.items():&#10;            if len(group) &gt; 1:&#10;                # Escolher o melhor nome do grupo&#10;                best_name = self._choose_best_name([name for _, name in group])&#10;                &#10;                # Aplicar o melhor nome a todos os elementos do grupo&#10;                for element, current_name in group:&#10;                    if current_name != best_name:&#10;                        name_elem = element.find('archimate:name', self.namespaces)&#10;                        name_elem.text = best_name&#10;                        logger.info(f&quot;Nome padronizado: '{current_name}' -&gt; '{best_name}'&quot;)&#10;&#10;    def _normalize_name_for_grouping(self, name: str) -&gt; str:&#10;        &quot;&quot;&quot;Normaliza nome para agrupamento de elementos similares&quot;&quot;&quot;&#10;        &#10;        # Remover sufixos comuns&#10;        normalized = re.sub(r'\s+(Service|API|Gateway|Database|System)$', '', name, flags=re.IGNORECASE)&#10;        &#10;        # Remover artigos e preposições&#10;        normalized = re.sub(r'\b(de|da|do|para|com|em)\b', '', normalized, flags=re.IGNORECASE)&#10;        &#10;        # Converter para lowercase e remover espaços extras&#10;        normalized = re.sub(r'\s+', ' ', normalized.lower().strip())&#10;        &#10;        return normalized&#10;&#10;    def _choose_best_name(self, names: List[str]) -&gt; str:&#10;        &quot;&quot;&quot;Escolhe o melhor nome de uma lista de nomes similares&quot;&quot;&quot;&#10;        &#10;        # Preferir nomes mais completos e descritivos&#10;        best_name = max(names, key=lambda name: (&#10;            len(name),  # Preferir nomes mais longos&#10;            name.count(' '),  # Preferir nomes com mais palavras&#10;            not name.islower(),  # Preferir nomes com capitalização adequada&#10;        ))&#10;        &#10;        return best_name&#10;&#10;    def generate_c4_quality_report(self, original_path: str, improved_path: str) -&gt; Dict:&#10;        &quot;&quot;&quot;Gera relatório detalhado das melhorias aplicadas&quot;&quot;&quot;&#10;        &#10;        try:&#10;            # Analisar diagrama original&#10;            original_tree = ET.parse(original_path)&#10;            original_analysis = self._analyze_diagram_structure(original_tree.getroot())&#10;            &#10;            # Analisar diagrama melhorado&#10;            improved_tree = ET.parse(improved_path)&#10;            improved_analysis = self._analyze_diagram_structure(improved_tree.getroot())&#10;            &#10;            # Gerar relatório comparativo&#10;            report = {&#10;                'original': original_analysis,&#10;                'improved': improved_analysis,&#10;                'improvements': self._calculate_improvements(original_analysis, improved_analysis),&#10;                'recommendations': self._generate_further_recommendations(improved_analysis)&#10;            }&#10;            &#10;            return report&#10;            &#10;        except Exception as e:&#10;            logger.error(f&quot;Erro ao gerar relatório: {e}&quot;)&#10;            return {}&#10;&#10;    def _analyze_diagram_structure(self, root: ET.Element) -&gt; Dict:&#10;        &quot;&quot;&quot;Analisa a estrutura do diagrama&quot;&quot;&quot;&#10;        &#10;        elements = root.findall('.//archimate:element', self.namespaces)&#10;        relationships = root.findall('.//archimate:relationship', self.namespaces)&#10;        &#10;        analysis = {&#10;            'total_elements': len(elements),&#10;            'total_relationships': len(relationships),&#10;            'element_types': {},&#10;            'relationship_types': {},&#10;            'has_documentation': 0,&#10;            'has_properties': 0,&#10;            'orphaned_elements': 0&#10;        }&#10;        &#10;        # Analisar elementos&#10;        connected_elements = set()&#10;        for rel in relationships:&#10;            connected_elements.add(rel.get('source'))&#10;            connected_elements.add(rel.get('target'))&#10;        &#10;        for element in elements:&#10;            # Tipo de elemento&#10;            elem_type = element.get('{http://www.w3.org/2001/XMLSchema-instance}type')&#10;            analysis['element_types'][elem_type] = analysis['element_types'].get(elem_type, 0) + 1&#10;            &#10;            # Documentação&#10;            if element.find('archimate:documentation', self.namespaces) is not None:&#10;                analysis['has_documentation'] += 1&#10;            &#10;            # Propriedades&#10;            if element.find('archimate:properties', self.namespaces) is not None:&#10;                analysis['has_properties'] += 1&#10;            &#10;            # Elementos órfãos&#10;            if element.get('identifier') not in connected_elements:&#10;                analysis['orphaned_elements'] += 1&#10;        &#10;        # Analisar relacionamentos&#10;        for rel in relationships:&#10;            rel_type = rel.get('{http://www.w3.org/2001/XMLSchema-instance}type')&#10;            analysis['relationship_types'][rel_type] = analysis['relationship_types'].get(rel_type, 0) + 1&#10;        &#10;        return analysis&#10;&#10;    def _calculate_improvements(self, original: Dict, improved: Dict) -&gt; Dict:&#10;        &quot;&quot;&quot;Calcula as melhorias aplicadas&quot;&quot;&quot;&#10;        &#10;        improvements = {&#10;            'documentation_improvement': improved['has_documentation'] - original['has_documentation'],&#10;            'properties_added': improved['has_properties'] - original['has_properties'],&#10;            'orphaned_elements_fixed': original['orphaned_elements'] - improved['orphaned_elements'],&#10;            'element_type_optimization': len(improved['element_types']) - len(original['element_types']),&#10;            'relationship_optimization': len(improved['relationship_types']) - len(original['relationship_types'])&#10;        }&#10;        &#10;        return improvements&#10;&#10;    def _generate_further_recommendations(self, analysis: Dict) -&gt; List[str]:&#10;        &quot;&quot;&quot;Gera recomendações adicionais para melhoria&quot;&quot;&quot;&#10;        &#10;        recommendations = []&#10;        &#10;        # Verificar cobertura de documentação&#10;        doc_coverage = (analysis['has_documentation'] / analysis['total_elements']) * 100&#10;        if doc_coverage &lt; 90:&#10;            recommendations.append(f&quot;Aumentar cobertura de documentação (atual: {doc_coverage:.1f}%)&quot;)&#10;        &#10;        # Verificar elementos órfãos&#10;        if analysis['orphaned_elements'] &gt; 0:&#10;            recommendations.append(f&quot;Conectar {analysis['orphaned_elements']} elementos órfãos&quot;)&#10;        &#10;        # Verificar densidade de relacionamentos&#10;        rel_density = analysis['total_relationships'] / max(analysis['total_elements'], 1)&#10;        if rel_density &lt; 0.8:&#10;            recommendations.append(&quot;Considerar adicionar mais relacionamentos para melhor conectividade&quot;)&#10;        &#10;        # Verificar diversidade de tipos de elementos&#10;        if len(analysis['element_types']) &lt; 3:&#10;            recommendations.append(&quot;Considerar diversificar tipos de elementos para melhor representação&quot;)&#10;        &#10;        return recommendations" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>