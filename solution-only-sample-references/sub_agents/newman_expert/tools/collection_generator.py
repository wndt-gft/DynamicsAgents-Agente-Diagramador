"""Newman Collection Generator - Generates universal Postman collections."""

import json
from typing import Dict, Any, List


def generate_universal_postman_collection(
    api_specification: str,
    test_scenarios: List[str],
    domain: str,
    complexity: str,
    endpoints: List[Dict[str, Any]],
    config: Dict[str, Any]
) -> Dict[str, Any]:
    """Generate universal Postman collection that works for any domain."""

    collection_name = f"{domain.title()} API Collection"

    # Generate requests for each scenario
    requests = []
    for i, scenario in enumerate(test_scenarios):
        request = _generate_generic_request(scenario, domain, i, endpoints, config)
        requests.append(request)

    # Add endpoint-specific requests
    for endpoint in endpoints:
        endpoint_request = _generate_endpoint_request(endpoint, domain, config)
        requests.append(endpoint_request)

    collection = {
        "info": {
            "name": collection_name,
            "description": f"Universal API collection for {domain} - Generated by Newman Expert",
            "schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json"
        },
        "auth": _generate_collection_auth(config),
        "event": _generate_collection_events(domain, config),
        "variable": _generate_collection_variables(domain, config),
        "item": requests
    }

    return collection


def _generate_generic_request(
    scenario: str,
    domain: str,
    index: int,
    endpoints: List[Dict[str, Any]],
    config: Dict[str, Any]
) -> Dict[str, Any]:
    """Generate a generic request for a test scenario."""

    # Use endpoint if available, otherwise generate generic endpoint
    if endpoints and index < len(endpoints):
        endpoint = endpoints[index]
        method = endpoint.get("method", "GET")
        path = endpoint.get("path", f"/api/{domain}/test")
    else:
        method = "GET"
        path = f"/api/{domain}/scenario-{index + 1}"

    return {
        "name": scenario,
        "request": {
            "method": method,
            "header": _generate_request_headers(config),
            "url": {
                "raw": f"{{{{base_url}}}}{path}",
                "host": ["{{{{base_url}}}}"],
                "path": path.strip("/").split("/")
            },
            "body": _generate_request_body(method, config) if method in ["POST", "PUT", "PATCH"] else None
        },
        "response": [],
        "event": _generate_request_events(scenario, domain, config)
    }


def _generate_endpoint_request(
    endpoint: Dict[str, Any],
    domain: str,
    config: Dict[str, Any]
) -> Dict[str, Any]:
    """Generate a request for a specific API endpoint."""

    method = endpoint.get("method", "GET")
    path = endpoint.get("path", "/api/test")
    description = endpoint.get("description", f"{method} {path}")

    return {
        "name": f"{method} {path} - {description}",
        "request": {
            "method": method,
            "header": _generate_request_headers(config),
            "url": {
                "raw": f"{{{{base_url}}}}{path}",
                "host": ["{{{{base_url}}}}"],
                "path": path.strip("/").split("/")
            },
            "body": _generate_request_body(method, config) if method in ["POST", "PUT", "PATCH"] else None
        },
        "response": [],
        "event": _generate_request_events(description, domain, config)
    }


def _generate_collection_auth(config: Dict[str, Any]) -> Dict[str, Any]:
    """Generate collection-level authentication."""

    auth_type = config.get("auth_type", "bearer")

    if auth_type == "bearer":
        return {
            "type": "bearer",
            "bearer": [
                {
                    "key": "token",
                    "value": "{{{{auth_token}}}}",
                    "type": "string"
                }
            ]
        }
    elif auth_type == "apikey":
        return {
            "type": "apikey",
            "apikey": [
                {
                    "key": "key",
                    "value": "X-API-Key",
                    "type": "string"
                },
                {
                    "key": "value",
                    "value": "{{{{api_key}}}}",
                    "type": "string"
                }
            ]
        }
    elif auth_type == "oauth2":
        return {
            "type": "oauth2",
            "oauth2": [
                {
                    "key": "accessToken",
                    "value": "{{{{oauth_token}}}}",
                    "type": "string"
                }
            ]
        }
    else:
        return {
            "type": "noauth"
        }


def _generate_collection_events(domain: str, config: Dict[str, Any]) -> List[Dict[str, Any]]:
    """Generate collection-level events."""

    return [
        {
            "listen": "prerequest",
            "script": {
                "type": "text/javascript",
                "exec": [
                    f"// Universal pre-request script for {domain}",
                    "console.log('Starting request for collection:', pm.info.requestName);",
                    "",
                    "// Set dynamic timestamps",
                    "pm.globals.set('timestamp', new Date().toISOString());",
                    "pm.globals.set('unix_timestamp', Math.floor(Date.now() / 1000));",
                    "",
                    "// Generate request ID for tracing",
                    "pm.globals.set('request_id', pm.variables.replaceIn('{{{{$guid}}}}'));",
                    "",
                    "// Custom pre-request logic",
                    f"// Domain: {domain}",
                    "// Add any domain-specific pre-request logic here"
                ]
            }
        },
        {
            "listen": "test",
            "script": {
                "type": "text/javascript",
                "exec": [
                    f"// Universal test script for {domain}",
                    "pm.test('Response time is acceptable', function () {",
                    "    pm.expect(pm.response.responseTime).to.be.below(5000);",
                    "});",
                    "",
                    "pm.test('Response has valid structure', function () {",
                    "    pm.response.to.have.status(200);",
                    "    pm.response.to.be.json;",
                    "});",
                    "",
                    "// Log response for debugging",
                    "console.log('Response status:', pm.response.status);",
                    "console.log('Response time:', pm.response.responseTime + 'ms');"
                ]
            }
        }
    ]


def _generate_collection_variables(domain: str, config: Dict[str, Any]) -> List[Dict[str, Any]]:
    """Generate collection-level variables."""

    return [
        {
            "key": "base_url",
            "value": config.get("base_url", f"https://api.{domain}.com"),
            "type": "string",
            "description": f"Base URL for {domain} API"
        },
        {
            "key": "api_version",
            "value": config.get("api_version", "v1"),
            "type": "string",
            "description": "API version"
        },
        {
            "key": "timeout",
            "value": str(config.get("timeout", 30000)),
            "type": "string",
            "description": "Request timeout in milliseconds"
        }
    ]


def _generate_request_headers(config: Dict[str, Any]) -> List[Dict[str, Any]]:
    """Generate request headers."""

    headers = [
        {
            "key": "Content-Type",
            "value": "application/json",
            "type": "text"
        },
        {
            "key": "Accept",
            "value": "application/json",
            "type": "text"
        }
    ]

    # Add custom headers from config
    custom_headers = config.get("custom_headers", {})
    for key, value in custom_headers.items():
        headers.append({
            "key": key,
            "value": value,
            "type": "text"
        })

    return headers


def _generate_request_body(method: str, config: Dict[str, Any]) -> Dict[str, Any]:
    """Generate request body for POST/PUT/PATCH methods."""

    if method == "POST":
        body_data = {
            "name": "Test Item",
            "description": "Test description",
            "status": "active",
            "timestamp": "{{{{timestamp}}}}"
        }
    elif method in ["PUT", "PATCH"]:
        body_data = {
            "name": "Updated Test Item",
            "description": "Updated description",
            "status": "active",
            "updatedAt": "{{{{timestamp}}}}"
        }
    else:
        return None

    # Apply custom body data if provided
    custom_body = config.get("request_body", {})
    body_data.update(custom_body)

    return {
        "mode": "raw",
        "raw": json.dumps(body_data, indent=2),
        "options": {
            "raw": {
                "language": "json"
            }
        }
    }


def _generate_request_events(scenario: str, domain: str, config: Dict[str, Any]) -> List[Dict[str, Any]]:
    """Generate request-level events."""

    return [
        {
            "listen": "test",
            "script": {
                "type": "text/javascript",
                "exec": [
                    f"// Test script for: {scenario}",
                    "pm.test('Status code is success', function () {",
                    "    pm.response.to.have.status(200);",
                    "});",
                    "",
                    "pm.test('Response time is acceptable', function () {",
                    "    pm.expect(pm.response.responseTime).to.be.below(3000);",
                    "});",
                    "",
                    "pm.test('Response has required fields', function () {",
                    "    const responseJson = pm.response.json();",
                    "    pm.expect(responseJson).to.have.property('timestamp');",
                    "});",
                    "",
                    "// Store response data for subsequent requests",
                    "if (pm.response.code === 200) {",
                    "    const responseJson = pm.response.json();",
                    "    if (responseJson.id) {",
                    "        pm.globals.set('last_created_id', responseJson.id);",
                    "    }",
                    "}"
                ]
            }
        }
    ]
