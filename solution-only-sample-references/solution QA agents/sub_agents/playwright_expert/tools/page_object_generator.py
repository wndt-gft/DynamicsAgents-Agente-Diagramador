"""Playwright Page Object Generator - Generates advanced page objects with cross-browser patterns."""

from typing import Dict, Any


def generate_playwright_page_objects(domain: str, test_complexity: str) -> str:
    """Generate advanced Playwright page objects."""

    complexity_features = _get_complexity_features(test_complexity)

    return f"""// pages/{domain}_page.js
// Generated by PlaywrightWeb_Expert - Advanced Page Object Pattern
// Domain: {domain} | Complexity: {test_complexity}

const {{ expect }} = require('@playwright/test');

class {domain.title()}Page {{
  constructor(page) {{
    this.page = page;
    this.baseUrl = process.env.BASE_URL || 'https://{domain}.com';
    
    // Universal selectors with fallbacks
    this.selectors = {{
      navigation: {{
        header: 'header, [role="banner"], .header, .navbar',
        menu: 'nav, [role="navigation"], .nav, .menu',
        logo: '[data-testid="logo"], .logo, h1'
      }},
      content: {{
        main: 'main, [role="main"], .main-content, #content',
        title: 'h1, [data-testid="title"], .page-title',
        loading: '[data-testid="loading"], .loader, .spinner'
      }},
      forms: {{
        input: 'input[type="text"], input[type="email"], textarea',
        submit: 'button[type="submit"], input[type="submit"], .submit-btn',
        error: '.error, .error-message, [role="alert"]'
      }}
    }};
  }}

  async navigate(path = '') {{
    await this.page.goto(`${{this.baseUrl}}${{path}}`);
    await this.waitForPageLoad();
  }}

  async waitForPageLoad() {{
    // Universal page load detection
    await Promise.race([
      this.page.waitForLoadState('networkidle'),
      this.page.waitForTimeout(10000)
    ]);
    
    // Wait for loading indicators to disappear
    const loadingSelector = this.selectors.content.loading;
    await this.page.waitForSelector(loadingSelector, {{ state: 'hidden', timeout: 5000 }})
      .catch(() => {{}}); // Ignore if no loading indicator exists
  }}

  async validateCoreFunctionality() {{
    // Universal core functionality validation
    await expect(this.page.locator(this.selectors.navigation.header)).toBeVisible();
    await expect(this.page.locator(this.selectors.content.main)).toBeVisible();
    
    // Verify interactive elements are functional
    const interactiveElements = await this.page.locator('button, a, input').count();
    expect(interactiveElements).toBeGreaterThan(0);
  }}

  async validateResponsiveLayout() {{
    const viewport = this.page.viewportSize();
    
    if (viewport.width <= 768) {{
      // Mobile validation
      await this.validateMobileLayout();
    }} else if (viewport.width <= 1024) {{
      // Tablet validation
      await this.validateTabletLayout();
    }} else {{
      // Desktop validation
      await this.validateDesktopLayout();
    }}
  }}

  async validateMobileLayout() {{
    // Mobile-specific validations
    const header = this.page.locator(this.selectors.navigation.header);
    await expect(header).toBeVisible();
    
    // Check for mobile menu if it exists
    const mobileMenu = this.page.locator('.mobile-menu, .hamburger, [data-testid="mobile-menu"]');
    if (await mobileMenu.count() > 0) {{
      await expect(mobileMenu).toBeVisible();
    }}
  }}

  async validateTabletLayout() {{
    // Tablet-specific validations
    const main = this.page.locator(this.selectors.content.main);
    await expect(main).toBeVisible();
    
    // Verify tablet-optimized layout
    const contentWidth = await main.boundingBox();
    expect(contentWidth.width).toBeGreaterThan(500);
  }}

  async validateDesktopLayout() {{
    // Desktop-specific validations
    const navigation = this.page.locator(this.selectors.navigation.menu);
    await expect(navigation).toBeVisible();
    
    // Verify desktop layout utilizes full width
    const main = this.page.locator(this.selectors.content.main);
    const mainWidth = await main.boundingBox();
    expect(mainWidth.width).toBeGreaterThan(800);
  }}

  async performCriticalUserJourney() {{
    // Universal critical user journey
    await this.page.waitForSelector(this.selectors.content.title);
    
    // Simulate user interactions
    const clickableElements = this.page.locator('button:visible, a:visible').first();
    if (await clickableElements.count() > 0) {{
      await clickableElements.click();
      await this.waitForPageLoad();
    }}
  }}

{_generate_complexity_methods(domain, complexity_features)}

  // Utility methods for cross-browser compatibility
  async safeClick(selector) {{
    await this.page.waitForSelector(selector, {{ state: 'visible' }});
    await this.page.locator(selector).click();
  }}

  async safeType(selector, text) {{
    await this.page.waitForSelector(selector, {{ state: 'visible' }});
    await this.page.locator(selector).fill(text);
  }}

  async safeWaitForSelector(selector, options = {{}}) {{
    const defaultOptions = {{ timeout: 5000, state: 'visible' }};
    return await this.page.waitForSelector(selector, {{ ...defaultOptions, ...options }});
  }}

  async takeScreenshot(name) {{
    await this.page.screenshot({{ 
      path: `screenshots/${{name}}_${{Date.now()}}.png`,
      fullPage: true
    }});
  }}
}}

module.exports = {{ {domain.title()}Page }};"""


def _get_complexity_features(complexity: str) -> Dict[str, bool]:
    """Get features based on complexity level."""

    features = {
        "simple": {
            "advanced_interactions": False,
            "api_integration": False,
            "file_handling": False,
            "authentication": True
        },
        "medium": {
            "advanced_interactions": True,
            "api_integration": False,
            "file_handling": True,
            "authentication": True
        },
        "complex": {
            "advanced_interactions": True,
            "api_integration": True,
            "file_handling": True,
            "authentication": True
        },
        "enterprise": {
            "advanced_interactions": True,
            "api_integration": True,
            "file_handling": True,
            "authentication": True
        }
    }

    return features.get(complexity, features["medium"])


def _generate_complexity_methods(domain: str, features: Dict[str, bool]) -> str:
    """Generate methods based on complexity features."""

    methods = []

    if features.get("authentication"):
        methods.append(f"""
  async login(username, password) {{
    await this.safeType('input[name="username"], input[type="email"]', username);
    await this.safeType('input[name="password"], input[type="password"]', password);
    await this.safeClick('button[type="submit"], .login-btn, [data-testid="login"]');
    await this.waitForPageLoad();
  }}

  async logout() {{
    await this.safeClick('.logout, [data-testid="logout"], .sign-out');
    await this.waitForPageLoad();
  }}""")

    if features.get("advanced_interactions"):
        methods.append(f"""
  async dragAndDrop(sourceSelector, targetSelector) {{
    await this.page.dragAndDrop(sourceSelector, targetSelector);
    await this.page.waitForTimeout(500); // Allow animation to complete
  }}

  async handleModal() {{
    const modal = this.page.locator('.modal, [role="dialog"], .popup');
    if (await modal.count() > 0) {{
      await expect(modal).toBeVisible();
      await this.safeClick('.modal .close, [data-testid="modal-close"]');
    }}
  }}""")

    if features.get("api_integration"):
        methods.append(f"""
  async interceptApiCall(endpoint, mockResponse) {{
    await this.page.route(`**/${{endpoint}}`, route => {{
      route.fulfill({{
        status: 200,
        contentType: 'application/json',
        body: JSON.stringify(mockResponse)
      }});
    }});
  }}

  async waitForApiResponse(endpoint) {{
    const response = await this.page.waitForResponse(response =>
      response.url().includes(endpoint) && response.status() === 200
    );
    return await response.json();
  }}""")

    if features.get("file_handling"):
        methods.append(f"""
  async uploadFile(inputSelector, filePath) {{
    await this.page.setInputFiles(inputSelector, filePath);
    await this.page.waitForTimeout(1000); // Allow file processing
  }}

  async downloadFile(downloadTriggerSelector) {{
    const downloadPromise = this.page.waitForEvent('download');
    await this.safeClick(downloadTriggerSelector);
    const download = await downloadPromise;
    return download;
  }}""")

    return '\n'.join(methods)
